"recently we created this restaurant backend"
"Restaurant.js"
import mongoose from 'mongoose';

const MenuItemSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Item name is required'],
    trim: true
  },
  description: {
    type: String,
    trim: true,
    default: ''
  },
  price: {
    type: Number,
    required: [true, 'Price is required'],
    min: 0
  },
  url: {
    type: String,
    default: ''
  },
  image: {
    type: String,
    default: ''
  },
  isVeg: {
    type: Boolean,
    default: true
  },
  isPopular: {
    type: Boolean,
    default: false
  },
  preparationTime: {
    type: Number,
    default: 15
  }
}, { timestamps: true, _id: true });

// âœ… NEW: Menu category schema (groups items by category)
const MenuCategorySchema = new mongoose.Schema({
  category: {
    type: String,
    required: [true, 'Category name is required'],
    trim: true
  },
  items: [MenuItemSchema]
}, { _id: false });

const RestaurantSchema = new mongoose.Schema({
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'RestaurantOwner',
    required: true
  },
  name: {
    type: String,
    required: [true, 'Restaurant name is required'],
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  image: {
    type: String,
    default: ''
  },
  cuisine: [{
    type: String,
    trim: true
  }],
  gstNumber: {
    type: String,
    trim: true
  },
  deliveryTime: {
    type: String,
    default: '30'
  },
  priceRange: {
    type: String,
    default: 'â‚¹â‚¹'
  },
  location: {
    area: {
      type: String,
      required: true,
      trim: true
    },
    address: {
      type: String,
      required: true,
      trim: true
    },
    city: {
      type: String,
      default: 'Vadodara'
    },
    state: {
      type: String,
      default: 'Gujarat'
    },
    pincode: {
      type: String,
      default: '390001'
    },
    coordinates: {
      type: [Number],
      default: [0, 0]
    }
  },
  contact: {
    phone: {
      type: String,
      default: ''
    },
    email: {
      type: String,
      default: ''
    }
  },
  
  // âœ… Menu items stored here
  menu: [MenuCategorySchema],
  
  status: {
    type: String,
    enum: ['active', 'inactive', 'closed'],
    default: 'active'
  },
  isActive: {
    type: Boolean,
    default: true
  },
  rating: {
    type: Number,
    default: 0,
    min: 0,
    max: 5
  },
  totalReviews: {
    type: Number,
    default: 0
  }
}, { timestamps: true });

export const Restaurant = mongoose.model('Restaurant', RestaurantSchema, 'new_registered_restaurants');


"RestaurantOwner.js"
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

const restaurantOwnerSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: [true, 'Name is required'],
      trim: true,
      maxlength: [100, 'Name cannot exceed 100 characters']
    },
    email: {
      type: String,
      required: [true, 'Email is required'],
      unique: true,
      lowercase: true,
      trim: true,
      match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please enter a valid email']
    },
    phone: {
      type: String,
      required: [true, 'Phone is required'],
      trim: true,
      // âœ… FIX: Remove strict 10-digit validation to allow country codes
      validate: {
        validator: function(v) {
          // Allow 10-13 digits with optional + and spaces
          return /^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/im.test(v.replace(/\s/g, ''));
        },
        message: 'Please enter a valid phone number'
      }
    },
    password: {
      type: String,
      required: [true, 'Password is required'],
      minlength: [6, 'Password must be at least 6 characters'],
      select: false
    },
    role: {
      type: String,
      default: 'restaurantOwner',
      enum: ['restaurantOwner', 'admin']
    },
    isActive: {
      type: Boolean,
      default: true
    },
    restaurant: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Restaurant'
    }
  },
  { 
    timestamps: true,
    collection: 'restaurantowners'
  }
);

// Hash password before saving
restaurantOwnerSchema.pre('save', async function (next) {
  if (!this.isModified('password')) {
    return next();
  }
  try {
    this.password = await bcrypt.hash(this.password, 12);
    next();
  } catch (error) {
    next(error);
  }
});

// Compare password method
restaurantOwnerSchema.methods.comparePassword = async function (candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

// Generate JWT
restaurantOwnerSchema.methods.getJwtToken = function () {
  return jwt.sign(
    { id: this._id }, 
    process.env.JWT_SECRET || 'default-secret-key-change-in-production', 
    { expiresIn: process.env.JWT_EXPIRES_IN || '7d' }
  );
};

export const RestaurantOwner = mongoose.model('RestaurantOwner', restaurantOwnerSchema);


"authRoutes.js"
import express from 'express';
import {
  registerRestaurantOwner,
  loginRestaurantOwner,
  getCurrentRestaurantOwner,
  updateRestaurantOwnerProfile,
  updateRestaurantOwnerPassword
} from '../controllers/restaurantOwnerAuthController.js';  // Ensure controller exists
import { authRestaurantOwner } from '../middleware/restaurantOwnerAuth.js';  // Middleware verifies JWT, sets req.user

const router = express.Router();

// Public routes (no auth)
router.post('/register', registerRestaurantOwner);  // Creates RestaurantOwner, auto-logs in
router.post('/login', loginRestaurantOwner);  // Validates creds, returns token

// Protected routes (require valid token)
router.get('/me', authRestaurantOwner, getCurrentRestaurantOwner);  // Returns current user profile
router.put('/profile', authRestaurantOwner, updateRestaurantOwnerProfile);  // Updates user info (e.g., name, email)
router.put('/password', authRestaurantOwner, updateRestaurantOwnerPassword);  // Updates password (old/new validation)

export default router;


"restaurantOwnerAuthController.js"
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import axios from 'axios';
import { RestaurantOwner } from '../models/RestaurantOwner.js';
import { Restaurant } from '../models/Restaurant.js';

// POST /api/auth/register
export const registerRestaurantOwner = async (req, res) => {
  try {
    const { name, email, password, phone, restaurant } = req.body;

    console.log('ðŸ“¥ Registration request received');
    console.log('Owner data:', { name, email, phone });
    console.log('Restaurant data:', restaurant);

    // âœ… Validation
    if (!name || !email || !password || !phone) {
      return res.status(400).json({ 
        success: false, 
        message: 'Name, email, password, and phone are required' 
      });
    }

    if (password.length < 6) {
      return res.status(400).json({ 
        success: false, 
        message: 'Password must be at least 6 characters' 
      });
    }

    if (!restaurant || !restaurant.name) {
      return res.status(400).json({ 
        success: false, 
        message: 'Restaurant name is required' 
      });
    }

    if (!restaurant.location || !restaurant.location.area || !restaurant.location.address) {
      return res.status(400).json({ 
        success: false, 
        message: 'Restaurant location (area and address) is required' 
      });
    }

    // âœ… Check existing user
    const existingOwner = await RestaurantOwner.findOne({ 
      $or: [{ email }, { phone }] 
    });
    
    if (existingOwner) {
      return res.status(400).json({ 
        success: false, 
        message: `User with this ${existingOwner.email === email ? 'email' : 'phone'} already exists` 
      });
    }

    // âœ… Create Restaurant Owner
    console.log('Creating restaurant owner...');
    const restaurantOwner = await RestaurantOwner.create({ 
      name: name.trim(), 
      email: email.trim().toLowerCase(), 
      password, 
      phone: phone.trim()
    });

    // Prevent duplicate restaurants for a given owner
    const existingRestaurant = await Restaurant.findOne({
      owner: restaurantOwner._id
    });
    if (existingRestaurant) {
      return res.status(400).json({
        success: false,
        message: 'You already have a restaurant registered.'
      });
    }


    console.log('âœ… Restaurant owner created:', restaurantOwner._id);

    // âœ… FIXED: Prepare cuisine array (ensure never empty)
    let cuisineArray = ['Multi-Cuisine'];
    if (restaurant.cuisine) {
      if (Array.isArray(restaurant.cuisine)) {
        const filtered = restaurant.cuisine.filter(c => c && c.trim());
        if (filtered.length > 0) cuisineArray = filtered;
      } else if (typeof restaurant.cuisine === 'string') {
        const filtered = restaurant.cuisine.split(',').map(c => c.trim()).filter(c => c);
        if (filtered.length > 0) cuisineArray = filtered;
      }
    }

    // âœ… Create Restaurant
    console.log('Creating restaurant...');
    const newRestaurant = await Restaurant.create({
      owner: restaurantOwner._id,
      name: restaurant.name.trim(),
      description: restaurant.description?.trim() || `Welcome to ${restaurant.name}!`,
      image: restaurant.image?.trim() || '',
      cuisine: cuisineArray,
      gstNumber: restaurant.gstNumber?.trim() || '',
      deliveryTime: restaurant.deliveryTime?.toString() || '30',
      priceRange: restaurant.priceRange || 'â‚¹â‚¹',
      location: {
        area: restaurant.location.area.trim(),
        address: restaurant.location.address.trim(),
        city: restaurant.location.city?.trim() || 'Vadodara',
        state: restaurant.location.state?.trim() || 'Gujarat',
        pincode: (restaurant.location.pincode?.toString() || '390001').trim(),
        coordinates: restaurant.location.coordinates || [0, 0]
      },
      contact: {
        phone: restaurant.contact?.phone?.trim() || phone.trim(),
        email: restaurant.contact?.email?.trim() || email.trim()
      },
      menu: [],  // âœ… ADDED: Initialize empty menu array
      status: 'active',
      isActive: true,
      isNewlyRegistered: true,  // âœ… ADDED: Mark as newly registered
      registeredAt: new Date()   // âœ… ADDED: Registration timestamp
    });
    console.log('âœ… Restaurant created:', newRestaurant._id);

    // âœ… Link restaurant to owner
    restaurantOwner.restaurant = newRestaurant._id;
    await restaurantOwner.save();

    console.log('âœ… Restaurant linked to owner');

    // âœ… âœ… âœ… PERMANENT AUTO-SYNC TO CUSTOMER DATABASE âœ… âœ… âœ…
    console.log('ðŸ”„ ========================================');
    console.log('ðŸ”„ STARTING AUTO-SYNC TO CUSTOMER DATABASE');
    console.log('ðŸ”„ ========================================');
    
    const syncStartTime = Date.now();
    
    try {
      const customerDBPayload = {
        restaurantId: newRestaurant._id.toString(),
        name: newRestaurant.name,
        description: newRestaurant.description,
        image: newRestaurant.image,
        cuisine: cuisineArray,
        gstNumber: newRestaurant.gstNumber || '',
        deliveryTime: newRestaurant.deliveryTime,
        priceRange: newRestaurant.priceRange,
        location: {
          area: newRestaurant.location.area,
          address: newRestaurant.location.address,
          city: newRestaurant.location.city,
          state: newRestaurant.location.state,
          pincode: newRestaurant.location.pincode,
          coordinates: newRestaurant.location.coordinates
        },
        contact: {
          phone: newRestaurant.contact.phone,
          email: newRestaurant.contact.email
        },
        rating: 0,
        totalReviews: 0,
        status: 'active',
        isActive: true, // âœ… ADDED: This was missing!
        isNewlyRegistered: true,
        registeredAt: new Date()
      };

      console.log('ðŸ“¦ Payload prepared:', JSON.stringify(customerDBPayload, null, 2));

      const CUSTOMER_BACKEND_URL = process.env.CUSTOMER_BACKEND_URL || 'http://localhost:5000';
      const syncUrl = `${CUSTOMER_BACKEND_URL}/api/restaurants/sync`;
      
      console.log('ðŸŒ Syncing to:', syncUrl);
      console.log('â±ï¸  Timeout: 15 seconds');

      const syncResponse = await axios.post(
        syncUrl,
        customerDBPayload,
        { 
          timeout: 15000, // âœ… INCREASED: from 10s to 15s
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );

      const syncDuration = Date.now() - syncStartTime;
      console.log(`ðŸ“¥ Sync response received in ${syncDuration}ms`);
      console.log('Response data:', syncResponse.data);

      if (syncResponse.data && syncResponse.data.success) {
        console.log('âœ… ========================================');
        console.log('âœ… SYNC SUCCESSFUL! Restaurant in Customer DB!');
        console.log('âœ… ========================================');
        console.log('ðŸ“ Customer DB Restaurant ID:', syncResponse.data.data._id);
      } else {
        console.warn('âš ï¸ ========================================');
        console.warn('âš ï¸ SYNC RETURNED SUCCESS: FALSE');
        console.warn('âš ï¸ ========================================');
        console.warn('Message:', syncResponse.data?.message || 'Unknown reason');
      }
    } catch (syncError) {
      const syncDuration = Date.now() - syncStartTime;
      
      console.error('âŒ ========================================');
      console.error('âŒ SYNC FAILED AFTER', syncDuration, 'ms');
      console.error('âŒ ========================================');
      console.error('Error type:', syncError.name);
      console.error('Error message:', syncError.message);
      
      if (syncError.code) {
        console.error('Error code:', syncError.code);
        
        if (syncError.code === 'ECONNREFUSED') {
          console.error('ðŸ’¡ SOLUTION: Customer backend is not running!');
          console.error('ðŸ’¡ Start it with: cd customer-backend && npm start');
        } else if (syncError.code === 'ETIMEDOUT') {
          console.error('ðŸ’¡ SOLUTION: Customer backend is too slow or not responding');
        }
      }
      
      if (syncError.response) {
        console.error('Response status:', syncError.response.status);
        console.error('Response data:', syncError.response.data);
      }

      if (syncError.response && syncError.response.data?.message) {
        return res.status(400).json({
          success: false,
          message: "Customer DB sync failed: " + syncError.response.data.message
        });
      }
      
      console.warn('âš ï¸ Registration completed but sync failed');
      console.warn('âš ï¸ Restaurant needs manual sync to Customer DB');
    }

    // âœ… Generate token
    const token = restaurantOwner.getJwtToken();

    // âœ… Success response
    res.status(201).json({
      success: true,
      token,
      data: { 
        user: {
          id: restaurantOwner._id,
          name: restaurantOwner.name,
          email: restaurantOwner.email,
          phone: restaurantOwner.phone
        },
        restaurant: {
          id: newRestaurant._id,
          name: newRestaurant.name,
          location: newRestaurant.location,
          status: newRestaurant.status
        }
      },
      message: 'Registration successful! Welcome to QuickBite.'
    });

  } catch (error) {
    console.error('âŒ Registration error:', error);
    
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map(err => err.message);
      return res.status(400).json({ 
        success: false, 
        message: messages.join(', '),
        error: error.message
      });
    }

    if (error.code === 11000) {
      const field = Object.keys(error.keyPattern || {})[0] || 'field';
      return res.status(400).json({ 
        success: false, 
        message: `This ${field} is already registered`
      });
    }

    res.status(500).json({ 
      success: false, 
      message: 'Registration failed. Please try again.',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// POST /api/auth/login
export const loginRestaurantOwner = async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ success: false, message: 'Email and password are required' });
    }

    const restaurantOwner = await RestaurantOwner.findOne({ email }).select('+password');
    console.log('Login attempt for email:', email, 'User found:', !!restaurantOwner);

    if (!restaurantOwner || !(await restaurantOwner.comparePassword(password))) {
      console.log('Invalid credentials for:', email);
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    const token = restaurantOwner.getJwtToken();

    const user = {
      id: restaurantOwner._id,
      name: restaurantOwner.name,
      email: restaurantOwner.email,
      phone: restaurantOwner.phone
    };

    console.log('Login successful for:', email);

    res.json({
      success: true,
      data: { token, user },
      message: 'Login successful'
    });
  } catch (error) {
    console.error('loginRestaurantOwner error:', error);
    res.status(500).json({ success: false, message: 'Failed to login restaurant owner' });
  }
};

// GET /api/auth/me
export const getCurrentRestaurantOwner = async (req, res) => {
  try {
    const restaurantOwner = await RestaurantOwner.findById(req.restaurantOwner.id).select('-password');
    if (!restaurantOwner) {
      return res.status(401).json({ success: false, message: 'Restaurant owner not found' });
    }

    const user = {
      id: restaurantOwner._id,
      name: restaurantOwner.name,
      email: restaurantOwner.email,
      phone: restaurantOwner.phone,
      role: restaurantOwner.role,
      isActive: restaurantOwner.isActive
    };

    res.json({ success: true, data: user });
  } catch (error) {
    console.error('getCurrentRestaurantOwner error:', error);
    res.status(500).json({ success: false, message: 'Failed to fetch restaurant owner profile' });
  }
};

// PUT /api/auth/profile
export const updateRestaurantOwnerProfile = async (req, res) => {
  try {
    const { name, phone } = req.body;
    const updates = {};

    if (name !== undefined) updates.name = name;
    if (phone !== undefined) updates.phone = phone;

    if (Object.keys(updates).length === 0) {
      return res.status(400).json({ success: false, message: 'No fields provided to update' });
    }

    if (phone !== undefined && phone !== req.restaurantOwner.phone) {
      const existingPhone = await RestaurantOwner.findOne({ phone });
      if (existingPhone && existingPhone._id.toString() !== req.restaurantOwner.id.toString()) {
        return res.status(400).json({ success: false, message: 'Phone number already in use' });
      }
    }

    const restaurantOwner = await RestaurantOwner.findByIdAndUpdate(
      req.restaurantOwner.id,
      updates,
      { new: true, runValidators: true }
    ).select('-password');

    if (!restaurantOwner) {
      return res.status(404).json({ success: false, message: 'Restaurant owner not found' });
    }

    res.json({
      success: true,
      data: {
        id: restaurantOwner._id,
        name: restaurantOwner.name,
        email: restaurantOwner.email,
        phone: restaurantOwner.phone
      },
      message: 'Profile updated successfully'
    });
  } catch (error) {
    console.error('updateRestaurantOwnerProfile error:', error);
    res.status(500).json({ success: false, message: 'Failed to update profile' });
  }
};

// PUT /api/auth/password
export const updateRestaurantOwnerPassword = async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;

    if (!currentPassword || !newPassword) {
      return res.status(400).json({ success: false, message: 'Current password and new password are required' });
    }

    if (newPassword.length < 6) {
      return res.status(400).json({ success: false, message: 'New password must be at least 6 characters' });
    }

    const restaurantOwner = await RestaurantOwner.findById(req.restaurantOwner.id).select('+password');

    if (!restaurantOwner || !(await restaurantOwner.comparePassword(currentPassword))) {
      return res.status(401).json({ success: false, message: 'Current password is incorrect' });
    }

    restaurantOwner.password = newPassword;
    await restaurantOwner.save();

    const token = restaurantOwner.getJwtToken();

    res.json({
      success: true,
      data: { token },
      message: 'Password updated successfully'
    });
  } catch (error) {
    console.error('updateRestaurantOwnerPassword error:', error);
    res.status(500).json({ success: false, message: 'Failed to update password' });
  }
};


"restaurantOwnerProfileController.js"
import { Restaurant } from '../models/Restaurant.js';
import { RestaurantOwner } from '../models/RestaurantOwner.js';

// âœ… GET PROFILE: Restaurant details for Profile Settings page
export const getRestaurantProfile = async (req, res) => {
  try {
    const restaurantOwnerId = req.restaurantOwner.id;
    
    const restaurant = await Restaurant.findOne({ owner: restaurantOwnerId });
    
    if (!restaurant) {
      return res.status(404).json({
        success: false,
        message: 'Restaurant profile not found'
      });
    }

    res.json({ 
      success: true, 
      data: restaurant 
    });
  } catch (error) {
    console.error('Get profile error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to load profile' 
    });
  }
};

// âœ… UPDATE PROFILE: Update restaurant details from Profile Settings
export const updateRestaurantProfile = async (req, res) => {
  try {
    const restaurantOwnerId = req.restaurantOwner.id;
    const { 
      name, 
      description, 
      image, 
      cuisine,
      gstNumber,
      deliveryTime, 
      priceRange, 
      location, 
      contact 
    } = req.body;

    if (!name || !location?.area || !location?.address) {
      return res.status(400).json({ 
        success: false, 
        message: 'Name, area, and address are required' 
      });
    }

    const updatedData = {
      name: name.trim(),
      description: description?.trim() || '',
      image: image || '',
      cuisine: cuisine || [],
      gstNumber: gstNumber?.trim() || '',
      deliveryTime: deliveryTime || '30',
      priceRange: priceRange || 'â‚¹â‚¹',
      location: {
        area: location.area.trim(),
        address: location.address.trim(),
        city: location.city?.trim() || '',
        state: location.state?.trim() || 'Gujarat',
        pincode: location.pincode?.toString() || '',
        coordinates: location.coordinates || [0, 0]
      },
      contact: {
        phone: contact?.phone || '',
        email: contact?.email || ''
      }
    };

    const restaurant = await Restaurant.findOneAndUpdate(
      { owner: restaurantOwnerId },
      { $set: updatedData },
      { new: true, runValidators: true }
    );

    if (!restaurant) {
      return res.status(404).json({ 
        success: false, 
        message: 'Restaurant not found' 
      });
    }

    res.json({ 
      success: true, 
      data: restaurant,
      message: 'Profile updated successfully' 
    });
  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({ 
      success: false, 
      message: error.message || 'Failed to update profile' 
    });
  }
};

// âœ… UPDATE OWNER INFO: Name, email, phone (optional)
export const updateOwnerInfo = async (req, res) => {
  try {
    const restaurantOwnerId = req.restaurantOwner.id;
    const { name, phone } = req.body;

    const owner = await RestaurantOwner.findByIdAndUpdate(
      restaurantOwnerId,
      { name, phone },
      { new: true, runValidators: true }
    ).select('-password');

    res.json({ 
      success: true, 
      data: owner,
      message: 'Owner info updated successfully' 
    });
  } catch (error) {
    console.error('Update owner info error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to update owner info' 
    });
  }
};


"restaurantOwnerAuth.js"
import jwt from 'jsonwebtoken';
import { RestaurantOwner } from '../models/RestaurantOwner.js';  // Model for auth (assumes exists with _id, password)

export const authRestaurantOwner = async (req, res, next) => {  // Renamed/exported correctly
  try {
    const authHeader = req.headers.authorization || '';  // Fixed: Lowercase 'authorization' standard
    const token = authHeader.startsWith('Bearer ')
      ? authHeader.split(' ')[1]  // Fixed: Split correctly to get token
      : null;

    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Not authorized, token missing'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);  // Verify with secret

    const restaurantOwner = await RestaurantOwner.findById(decoded.id).select('-password');  // Exclude password
    if (!restaurantOwner) {
      return res.status(401).json({
        success: false,
        message: 'Not authorized, restaurant owner not found'
      });
    }

    req.restaurantOwner = { 
      id: restaurantOwner._id,  // Attach ID (add more: email, role if needed)
      // Optional: req.restaurantOwner = restaurantOwner; for full user object
    };
    next();
  } catch (error) {
    console.error('authRestaurantOwner error:', error);  // Log for debugging
    return res.status(401).json({
      success: false,
      message: 'Not authorized, token invalid'
    });
  }
};


"db.js"
import mongoose from 'mongoose';

export const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI, {
      dbName: process.env.MONGO_DB_NAME || 'quickbite_restaurant_owners',  // Fixed: Restaurant owner themed DB
      retryWrites: true,  // Added: For MongoDB 4.0+ reliability
      w: 'majority'  // Added: Write concern
    });

    console.log(`MongoDB connected: ${conn.connection.host} (DB: ${process.env.MONGO_DB_NAME || 'quickbite_restaurant_owners'})`);
  } catch (error) {
    console.error('MongoDB connection error:', error.message);
    process.exit(1);  // Exit on DB failure
  }
};

